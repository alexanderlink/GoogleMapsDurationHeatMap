<!DOCTYPE html>
<html>
  <head>
    <title>Distance Matrix service</title>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #map-canvas {
        height: 100%;
        width: 50%;
      }
      #content-pane {
        float:right;
        width:48%;
        padding-left: 2%;
      }
      #outputDiv {
        font-size: 10px;
      }
      #errorDiv {
        font-size: 10px;
      }
    </style>
    <script src="q.js"></script>
    <script>
var map;
var geocoder;
var bounds = new google.maps.LatLngBounds();
var markersArray = [];
var areas = {};
var processed = -1;

var service;
var delta;
var count;
var sleep;
var rounds;
var minSleep = 1000;
var allOrigins = [];


var destination = new google.maps.LatLng(49.2936688, 8.6417212);

var destinationIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=D|FF0000|000000';
var originIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=O|FFFF00|000000';

function initialize() {
  var opts = {
    center: new google.maps.LatLng(49.2936688, 8.6417212),
    zoom: 10
  };
  map = new google.maps.Map(document.getElementById('map-canvas'), opts);
  geocoder = new google.maps.Geocoder();
}

function calculateOrigins(dest) {
  var origins = [];
  var log = '';
  log += dest.lat() + " / " + dest.lng() + "\n";
  for(var i = 0; i < count; i++) {
    for(var j = 0; j < count; j++) {
      var lat = dest.lat() - (delta*count/2.0) + (delta/2.0) + (delta*i);
      var lng = dest.lng() - (delta*count/2.0) + (delta/2.0) + (delta*j);
      log += lat + " / " + lng + "\n";
      origins.push(new google.maps.LatLng(lat, lng));
    }
  }
  return origins;
}

function calcColor(min, max, value) {
  var percent = (value-min) / (max-min);
  if(percent <= 0.05) return '#00ff00'
  if(percent <= 0.15) return '#00df00'
  if(percent <= 0.25) return '#1fbf00'
  if(percent <= 0.35) return '#3f9f00'
  if(percent <= 0.45) return '#5f7f00'
  if(percent <= 0.55) return '#7f5f00'
  if(percent <= 0.65) return '#9f3f00'
  if(percent <= 0.75) return '#bf1f00'
  if(percent <= 0.85) return '#df0000'
  if(percent <= 0.95) return '#ff0000';
  if(percent <= 1.00) return '#ff0000';
  return '#0000ff';
}

function markRectangles(areas) {
  var max = 0;
  var min = 999999999;
  Object.keys(areas).forEach(function(key) {
    var area = areas[key];
    min = Math.min(min, area.duration.value);
    max = Math.max(max, area.duration.value);
  });
  Object.keys(areas).forEach(function(key) {
    var area = areas[key];
    markRectangle(area.origin, calcColor(min, max, area.duration.value), area.duration.text, area.distance.text);
  });  
}

function markRectangle(location, color, durationText, distanceText) {
   var lat = location.lat();
   var lng = location.lng();
   outputDiv.innerHTML = '...mark rectangle: ' + lat + '/' + lng + '<br>' + outputDiv.innerHTML;
   var rectangle = new google.maps.Rectangle({
          strokeColor: color,
          strokeOpacity: 0.55,
          strokeWeight: 0.2,
          fillColor: color,
          fillOpacity: 0.5,
          map: map,
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(lat-(delta/2.0), lng-(delta/2.0)),
            new google.maps.LatLng(lat+(delta/2.0), lng+(delta/2.0))
          )
        });
  google.maps.event.addListener(rectangle, 'click', function() {
      document.getElementById('duration').value = durationText;
      document.getElementById('distance').value = distanceText;
      document.getElementById('from').value = location.lat() + ', ' + location.lng();
      document.getElementById('to').value = destination.lat() + ', ' + destination.lng();
      checkRoute(location);
  });
}

function checkRoute(location) {
  service.getDistanceMatrix(
    {
      origins: [location],
      destinations: [destination],
      travelMode: google.maps.TravelMode.DRIVING,
      unitSystem: google.maps.UnitSystem.METRIC,
      avoidHighways: false,
      avoidTolls: false
    }, 
    function(response, status) {
      logInfo(JSON.stringify(response, null, '  '));
    });
}

function partial(funct) {
    var args = Array.prototype.slice.call(arguments).splice(1);
    return function() {
      var allArgs = args.concat(Array.prototype.slice.call(arguments));
      return funct.apply(this, allArgs);
    };
}

function calculateDistances() {
  delta = Number(document.getElementById("delta").value);
  count = Number(document.getElementById("count").value);
  sleep = Number(document.getElementById("sleep").value);
  service = new google.maps.DistanceMatrixService();
  allOrigins = calculateOrigins(destination);
  areas = {};
  var allDeferred = [];
  var promises = [];
  rounds = allOrigins.length/25;
  addMarker(destination);
  
  processRecursive(0, rounds).then(
    function success() {
      markRectangles(areas);
    },
    function error(err) {
      logError('Some promises failed!');
    }
  );
}

function processRecursive(i, rounds, timeout) {
  var deferred = Q.defer();
  if(!timeout) timeout = 0;
  console.log('processRecursive ' + i + ', ' + rounds + ', ' + timeout);

  setTimeout(partial(function(i, rounds, timeout){ 
  
    var start = i*15;
    var end = start+25 > allOrigins.length ? allOrigins.length : start+25;
    var origins = allOrigins.slice(start, end);
    service.getDistanceMatrix(
    {
      origins: origins,
      destinations: [destination],
      travelMode: google.maps.TravelMode.DRIVING,
      unitSystem: google.maps.UnitSystem.METRIC,
      avoidHighways: false,
      avoidTolls: false
    }, partial(function(origins, response, status) {
      callback(i, origins, response, status).then(
        function success() {
          if(i < rounds) {
            processRecursive(i+1, rounds, minSleep).then(
              function success2() {
                deferred.resolve();
              },
              function error2(err) {
                deferred.reject(err);
              }
            )
          } else {
            deferred.resolve();
          }
        },
        function error(err) {
          if(err === "OVER_QUERY_LIMIT") {
            if(timeout < minSleep) timeout = minSleep
            else timeout = timeout * 2;
            console.log('OVER_QUERY_LIMIT - increasing to ' + timeout);
            processRecursive(i, rounds, timeout).then(
              function success2() {
                deferred.resolve();
              },
              function error2(err) {
                deferred.reject(err);
              }
            )
          } else {
            deferred.reject(err);
          }
        }
      );
    }, origins));

  }, i, rounds, timeout), timeout);

  return deferred.promise;
}

function callback(iteration, reqOrigins, response, status) {
  var deferred = Q.defer();
  try {
    console.log('Callback['+iteration+']: ' + response + '/' + status);
    if (status != google.maps.DistanceMatrixStatus.OK) {
      if(status !== "OVER_QUERY_LIMIT") logError('Error1 was: ' + status + ' / ' + JSON.stringify(response));
      deferred.reject(status);
    } else {
      var origins = response.originAddresses;
      var destinations = response.destinationAddresses;
      var outputDiv = document.getElementById('outputDiv');
      //outputDiv.innerHTML = '';
      //deleteOverlays();

      //addMarker(destination, true, destination);

      for (var i = 0; i < origins.length; i++) {
        var results = response.rows[i].elements;
        for (var j = 0; j < results.length; j++) {
          //addMarker(origins[i], false, reqOrigins[i], results[j].duration);
          //addMarker(destinations[j], true, destination, results[j].duration);
          var loc = reqOrigins[i];
          if(loc) {
            var result = results[j];
            if(result && result.distance && result.duration) {
              areas[loc.lat()+'/'+loc.lng()] = {origin: loc, resultOrigin: origins[i], distance: result.distance, duration: result.duration};
              //outputDiv.innerHTML = origins[i] + ': ' + results[j].distance.text + ' in '+ results[j].duration.text + '<br>' + outputDiv.innerHTML;
              logInfo(iteration + '/' + rounds + '  ' + loc.lat() + ' / ' + loc.lng() + ' : ' + result.distance.text + ' in '+ result.duration.text);
            } else {
              console.warn('result incomplete i: ' + i + ', iteration: ' + iteration + ', j: ' + j + ' - ' + result);
            }
          } else {
            console.warn('loc undefined i: ' + i + ', iteration: ' + iteration);
          }
        }
      }
      deferred.resolve();
    }
  } catch(err) {
    logError('Error2 was: ' + err);
    deferred.reject(err);
  }
  return deferred.promise;
}

function addMarker(reqLocation) {
    var marker = new google.maps.Marker({
        map: map,
        position: reqLocation,
        icon: destinationIcon
      });
}

/*function addMarkerOld(location, isDestination, reqLocation, duration) {
  var icon;
  if (isDestination) {
    icon = destinationIcon;
  } else {
    icon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=' + duration.text + '|FFFF00|000000';
  }
  geocoder.geocode({'address': location}, function(results, status) {
    if (status == google.maps.GeocoderStatus.OK) {
      bounds.extend(results[0].geometry.location);
      map.fitBounds(bounds);
      var marker = new google.maps.Marker({
        map: map,
        position: reqLocation,
        icon: icon,
        title: duration ? ''+duration : ''
      });
      markersArray.push(marker);*/
      
      /*var rectangle = new google.maps.Rectangle({
          strokeColor: '#FF0000',
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: '#FF0000',
          fillOpacity: 0.1,
          map: map,
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(49.2936688, 8.6317212),
            new google.maps.LatLng(49.2836688, 8.6417212)
          )
        });*/
      
      
    /*} else {
      logError('Geocode was not successful for the following reason: '
        + status);
    }
  });
}*/

/*function deleteOverlays() {
  for (var i = 0; i < markersArray.length; i++) {
    markersArray[i].setMap(null);
  }
  markersArray = [];
}*/

function logError(err) {
  var div = document.getElementById('errorDiv');
  div.innerHTML = err + '<br>' + div.innerHTML;
}

function logInfo(message) {
  var div = document.getElementById('outputDiv');
  div.innerHTML = message + '<br>' + div.innerHTML;
}

google.maps.event.addDomListener(window, 'load', initialize);

    </script>
  </head>
  <body>
    <div id="content-pane">
      <div id="inputs">
        <p>
          <input type="text" id="delta" value="0.005" size="12"></input> 
          <input type="text" id="count" value="8" size="12"></input> 
          <input type="text" id="sleep" value="3000" size="12"></input> <br/>
          <button type="button" onclick="calculateDistances();">Calculate distances</button> <br/>
          <input type="text" id="distance" value="km" size="12" readonly></input> 
          <input type="text" id="duration" value="min" size="12" readonly></input> <br/>
          <input type="text" id="from" value="from" size="40" readonly></input> <br/>
          <input type="text" id="to" value="to" size="40" readonly></input>
        </p>
      </div>
      <div id="errorDiv" style="color:red"></div>
      <div id="outputDiv"></div>
    </div>
      
    <div id="map-canvas"></div>
  </body>
</html>

