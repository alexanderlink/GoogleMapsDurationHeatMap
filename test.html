<!DOCTYPE html>
<html>
  <head>
    <title>Distance Matrix service</title>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #map-canvas {
        height: 100%;
        width: 70%;
      }
      #content-pane {
        float:right;
        width:28%;
        padding-left: 2%;
      }
      #outputDiv {
        font-size: 10px;
      }
      #errorDiv {
        font-size: 10px;
      }
    </style>
    <script src="q.js"></script>
    <script>
var map;
var geocoder;
var bounds = new google.maps.LatLngBounds();
var markersArray = [];
var areas = {};
var processed = -1;

var service;
var delta;
var count;
var sleep;
var rounds;
var minSleep = 1000;
var allOrigins = [];


var destination = new google.maps.LatLng(49.2936688, 8.6417212);

var destinationIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=D|FF0000|000000';
var originIcon = 'https://chart.googleapis.com/chart?chst=d_map_pin_letter&chld=O|FFFF00|000000';

function initialize() {
  var opts = {
    center: new google.maps.LatLng(49.2936688, 8.6417212),
    zoom: 10
  };
  map = new google.maps.Map(document.getElementById('map-canvas'), opts);
  geocoder = new google.maps.Geocoder();
}

function calculateOrigins(dest) {
  var origins = [];
  var log = '';
  log += dest.lat() + " / " + dest.lng() + "\n";
  for(var i = 0; i < count; i++) {
    for(var j = 0; j < count; j++) {
      var lat = dest.lat() - (delta*count/2.0) + (delta/2.0) + (delta*i);
      var lng = dest.lng() - (delta*count/2.0) + (delta/2.0) + (delta*j);
      log += lat + " / " + lng + "\n";
      origins.push(new google.maps.LatLng(lat, lng));
    }
  }
  return origins;
}

function calcColor(min, max, value) {
  var percent = (value-min) / (max-min);
  //console.log(value + ' -> ' + percent);
  if(percent <= 0.05) return '#00ff00'
  if(percent <= 0.15) return '#00df00'
  if(percent <= 0.25) return '#1fbf00'
  if(percent <= 0.35) return '#3f9f00'
  if(percent <= 0.45) return '#5f7f00'
  if(percent <= 0.55) return '#7f5f00'
  if(percent <= 0.65) return '#9f3f00'
  if(percent <= 0.75) return '#bf1f00'
  if(percent <= 0.85) return '#df0000'
  if(percent <= 0.95) return '#ff0000';
  if(percent <= 1.00) return '#ff0000';
  return '#0000ff';
}

function markRectangles(areas) {
  var max = 0;
  var min = 999999999;
  Object.keys(areas).forEach(function(key) {
    var area = areas[key];
    min = Math.min(min, area.duration.value);
    max = Math.max(max, area.duration.value);
  });
  Object.keys(areas).forEach(function(key) {
    var area = areas[key];
    markRectangle(area.origin, calcColor(min, max, area.duration.value), area.duration.text, area.distance.text);
  });  
}

function markRectangle(location, color, durationText, distanceText) {
   var lat = location.A;
   var lng = location.F;
   outputDiv.innerHTML = '...mark rectangle: ' + lat + '/' + lng + '<br>' + outputDiv.innerHTML;
   var rectangle = new google.maps.Rectangle({
          strokeColor: color,
          strokeOpacity: 0.55,
          strokeWeight: 0.2,
          fillColor: color,
          fillOpacity: 0.5,
          map: map,
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(lat-(delta/2.0), lng-(delta/2.0)),
            new google.maps.LatLng(lat+(delta/2.0), lng+(delta/2.0))
          )
        });
  markersArray.push(rectangle);
  google.maps.event.addListener(rectangle, 'click', function() {
      document.getElementById('duration').value = durationText;
      document.getElementById('distance').value = distanceText;
      document.getElementById('from').value = lat + ', ' + lng;
      document.getElementById('to').value = destination.lat() + ', ' + destination.lng();
      checkRoute(location);
  });
}

function checkRoute(location) {
  service.getDistanceMatrix(
    {
      origins: [location],
      destinations: [destination],
      travelMode: google.maps.TravelMode.DRIVING,
      unitSystem: google.maps.UnitSystem.METRIC,
      avoidHighways: false,
      avoidTolls: false
    }, 
    function(response, status) {
      logInfo(JSON.stringify(response, null, '  '));
    });
}

function partial(funct) {
    var args = Array.prototype.slice.call(arguments).splice(1);
    return function() {
      var allArgs = args.concat(Array.prototype.slice.call(arguments));
      return funct.apply(this, allArgs);
    };
}

function calculateDistances() {
  deleteOverlays();
  addMarker(destination);
  if(document.getElementById("result").value) {
    areas = JSON.parse(document.getElementById("result").value);
    markRectangles(areas);
  } else {
    delta = Number(document.getElementById("delta").value);
    count = Number(document.getElementById("count").value);
    sleep = Number(document.getElementById("sleep").value);
    service = new google.maps.DistanceMatrixService();
    allOrigins = calculateOrigins(destination);
    areas = {};
    rounds = allOrigins.length/25;
    processRecursive(0, rounds).then(
      function success() {
        document.getElementById("result").value = JSON.stringify(areas);
        markRectangles(areas);
      },
      function error(err) {
        logError('Some promises failed!');
      }
    );
  }
}

function processRecursive(i, rounds, timeout) {
  var deferred = Q.defer();
  if(!timeout) timeout = 0;
  console.log('processRecursive ' + i + ', ' + rounds + ', ' + timeout);
  setTimeout(partial(function(i, rounds, timeout){ 
    var maxPerRequest = 25;
    var start = i*maxPerRequest;
    var end = start+maxPerRequest;
    if(end > allOrigins.length) end = allOrigins.length;
    if(end > start) {
      var origins = allOrigins.slice(start, end);
      service.getDistanceMatrix(
      {
        origins: origins,
        destinations: [destination],
        travelMode: google.maps.TravelMode.DRIVING,
        unitSystem: google.maps.UnitSystem.METRIC,
        avoidHighways: false,
        avoidTolls: false
      }, partial(function(origins, response, status) {
        callback(i, origins, response, status).then(
          function success() {
            if(i < rounds) {
              processRecursive(i+1, rounds, timeout).then(
                function success2() {
                  deferred.resolve();
                },
                function error2(err) {
                  deferred.reject(err);
                }
              )
            } else {
              deferred.resolve();
            }
          },
          function error(err) {
            if(err === "OVER_QUERY_LIMIT") {
              if(timeout < minSleep) timeout = minSleep
              else timeout = timeout * 2;
              console.log('OVER_QUERY_LIMIT - increasing to ' + timeout);
              processRecursive(i, rounds, timeout).then(
                function success2() {
                  deferred.resolve();
                },
                function error2(err) {
                  deferred.reject(err);
                }
              )
            } else {
              deferred.reject(err);
            }
          }
        );
      }, origins));
    } else {
      deferred.resolve();
    }
  }, i, rounds, timeout), timeout);
  return deferred.promise;
}

function callback(iteration, reqOrigins, response, status) {
  var deferred = Q.defer();
  try {
    console.log('Callback['+iteration+']: ' + response + '/' + status);
    if (status != google.maps.DistanceMatrixStatus.OK) {
      if(status !== "OVER_QUERY_LIMIT") logError('Error1 was: ' + status + ' / ' + JSON.stringify(response));
      deferred.reject(status);
    } else {
      var outputDiv = document.getElementById('outputDiv');
      for (var i = 0; i < reqOrigins.length; i++) {
        var origin = reqOrigins[i];
        var result = response.rows[i].elements[0];
        if(origin) {
          if(result && result.distance && result.duration) {
            areas[origin.lat()+'/'+origin.lng()] = {origin: origin, distance: result.distance, duration: result.duration};
            logInfo(iteration + '/' + rounds + '  ' + origin.lat() + ' / ' + origin.lng() + ' : ' + result.distance.text + ' in '+ result.duration.text);
          } else {
            console.warn('result incomplete i: ' + i + ', iteration: ' + iteration + ' - ' + result);
          }
        } else {
          console.warn('origin undefined i: ' + i + ', iteration: ' + iteration);
        }
      }
      deferred.resolve();
    }
  } catch(err) {
    logError('Error2 was: ' + err);
    deferred.reject(err);
  }
  return deferred.promise;
}

function addMarker(reqLocation) {
  var marker = new google.maps.Marker({
      map: map,
      position: reqLocation,
      icon: destinationIcon
    });
  markersArray.push(marker);
}

function logError(err) {
  var div = document.getElementById('errorDiv');
  div.innerHTML = err + '<br>' + div.innerHTML;
}

function logInfo(message) {
  var div = document.getElementById('outputDiv');
  div.innerHTML = message + '<br>' + div.innerHTML;
}

function deleteOverlays() {
  for (var i = 0; i < markersArray.length; i++) {
    markersArray[i].setMap(null);
  }
  markersArray = [];
}

google.maps.event.addDomListener(window, 'load', initialize);

    </script>
  </head>
  <body>
    <div id="content-pane">
      <div id="inputs">
        <p>
          <input type="text" id="delta" value="0.005" size="12"></input> 
          <input type="text" id="count" value="8" size="12"></input> 
          <input type="text" id="sleep" value="3000" size="12"></input> <br/>
          <button type="button" onclick="calculateDistances();">Calculate distances</button> <br/>
          <input type="text" id="distance" value="km" size="12" readonly></input> 
          <input type="text" id="duration" value="min" size="12" readonly></input> <br/>
          <input type="text" id="from" value="from" size="40" readonly></input> <br/>
          <input type="text" id="to" value="to" size="40" readonly></input><br/>
          <input type="text" id="result" value="" size="40"></input>
        </p>
      </div>
      <div id="errorDiv" style="color:red"></div>
      <div id="outputDiv"></div>
    </div>
      
    <div id="map-canvas"></div>
  </body>
</html>

